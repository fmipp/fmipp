/* Simulation code for Simple generated by the OpenModelica Compiler 1.9.0 Beta1 (r????). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "Simple_functions.h"

#include "_Simple.h"
#include "Simple_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = {"",-1,-1,-1,-1,1};
const VAR_INFO dummyVAR_INFO = {-1,"","",(FILE_INFO){"",-1,-1,-1,-1,1}};
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif

void setupDataStruc(DATA *data)
{
  ASSERT(data,"Error while initialize Data");
  data->modelData.modelName = "Simple";
  data->modelData.modelFilePrefix = "Simple";
  data->modelData.modelDir = "/home/wolfi/fmipp/trunk/examples/omc/einfach";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  
  data->modelData.nStates = 1;
  data->modelData.nVariablesReal = 2*1+1;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 0;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 1;
  data->modelData.nParametersInteger = 0;
  data->modelData.nParametersBoolean = 0;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 0;
  data->modelData.nJacobians = 5;
  data->modelData.nHelpVars = 0;
  
  data->modelData.nAliasReal = 0;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 0;
  data->modelData.nSamples = 0;
  data->modelData.nInitEquations = 0;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 0;
  data->modelData.nExtObjs = 0;
  data->modelData.nFunctions = 0;
  data->modelData.nEquations = 2;
  data->modelData.nNonLinearSystems = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}

/* Some empty lines, since emptyCount is not implemented in susan! */


void setupDataStruc2(DATA *data)
{
  const struct FUNCTION_INFO funcInfo[1] = {{-1,"",omc_dummyFileInfo}};
  memcpy(data->modelData.functionNames, &funcInfo, data->modelData.nFunctions*sizeof(FUNCTION_INFO));
  
  const VAR_INFO** equationInfo_cref1 = (const VAR_INFO**)calloc(1,sizeof(VAR_INFO*));
  equationInfo_cref1[0] = &$Pz__varInfo;
  const VAR_INFO** equationInfo_cref2 = (const VAR_INFO**)calloc(1,sizeof(VAR_INFO*));
  equationInfo_cref2[0] = &$P$DER$Px__varInfo;
  const struct EQUATION_INFO equationInfo[2] = {
    {1,"SES_SIMPLE_ASSIGN 1",1,equationInfo_cref1},
    {2,"SES_SIMPLE_ASSIGN 2",1,equationInfo_cref2}
  };
  const int n_omc_equationInfo_reverse_prof_index = 0;
  const int omc_equationInfo_reverse_prof_index[] = {
    
  };
  memcpy(data->modelData.equationInfo, &equationInfo, data->modelData.nEquations*sizeof(EQUATION_INFO));
  
  data->modelData.nProfileBlocks = n_omc_equationInfo_reverse_prof_index;
  data->modelData.equationInfo_reverse_prof_index = (int*) malloc(data->modelData.nProfileBlocks*sizeof(int));
  memcpy(data->modelData.equationInfo_reverse_prof_index, omc_equationInfo_reverse_prof_index, data->modelData.nProfileBlocks*sizeof(int));
}

/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_sampleInit(DATA *data)
{

}

int function_updateSample(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  DEBUG_INFO(LOG_INIT, "updating start-values:");
  
  return 0;
}

int initial_residual(DATA *data, double* initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  DEBUG_INFO(LOG_RES_INIT, "updating initial_residuals:");
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundParameters(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


void eqFunction_1(DATA *data)
{
  modelica_real tmp0;
  tmp0 = $Px;
  $Pz = (tmp0 * tmp0); 
}


void eqFunction_2(DATA *data)
{
  $P$DER$Px = ($Pp * $Px); 
}

int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_1(data);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data,int omc_thread_number)
{
  eqFunction_2(data);
}
static void (*functionODE_systems[1])(DATA *, int) = {
  functionODE_system0
};

void function_initMemoryState()
{
  push_memory_states(1);
}

int functionODE(DATA *data)
{
  int id,th_id;
  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();

  data->simulationInfo.discreteCall = 0;
  for (id=0; id<1; id++) {
    th_id = omp_get_thread_num();
    functionODE_systems[id](data,th_id);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  state mem_state;
 data->simulationInfo.discreteCall = 0;
  mem_state = get_memory_state();
  eqFunction_1(data);
  restore_memory_state(mem_state);
  
  return 0;
}

int function_ZeroCrossings(DATA *data, double *gout,double *t)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

const int INDEX_JAC_G = 0;
const int INDEX_JAC_A = 1;
const int INDEX_JAC_B = 2;
const int INDEX_JAC_C = 3;
const int INDEX_JAC_D = 4;

int initialAnalyticJacobianG(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianA(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianB(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianC(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianD(DATA* data)
{
  return 1;
}

int functionJacG_column(DATA* data)
{
  return 0;
}
int functionJacA_column(DATA* data)
{
  return 0;
}
int functionJacB_column(DATA* data)
{
  return 0;
}
int functionJacC_column(DATA* data)
{
  return 0;
}
int functionJacD_column(DATA* data)
{
  return 0;
}

const char *linear_model_frame =
  "model linear_Simple\n  parameter Integer n = 1; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n"
  "  parameter Real x0[1] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[1,1] = [%s];\n"
  "  parameter Real B[1,0] = zeros(1,0);%s\n"
  "  parameter Real C[0,1] = zeros(0,1);%s\n"
  "  parameter Real D[0,0] = zeros(0,0);%s\n"
  "  Real x[1](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[0];\n"
  "\n  Real x_Px = x[1];\n      \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_Simple;\n"
;

#ifdef __cplusplus
}
#endif

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}

