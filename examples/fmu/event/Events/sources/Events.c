/* Simulation code for Events generated by the OpenModelica Compiler 1.9.0 Beta2 (r????). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "Events_functions.h"

#include "_Events.h"
#include "Events_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif

void setupDataStruc(DATA *data)
{
  ASSERT(data, "Error while initialize Data");
  data->modelData.modelName = "Events";
  data->modelData.modelFilePrefix = "Events";
  data->modelData.modelDir = "/home/wolfi/fmipp/examples/omc/event";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  
  data->modelData.nStates = 1;
  data->modelData.nVariablesReal = 2*1+1;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 0;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 1;
  data->modelData.nParametersInteger = 0;
  data->modelData.nParametersBoolean = 0;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 0;
  data->modelData.nJacobians = 5;
  data->modelData.nHelpVars = 0;
  
  data->modelData.nAliasReal = 0;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 1;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 1;
  data->modelData.nInitEquations = 0;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 0;    /* data->modelData.nInitEquations + data->modelData.nInitAlgorithms */
  data->modelData.nExtObjs = 0;
  data->modelData.nFunctions = 0;
  data->modelData.nEquations = 2;
  data->modelData.nNonLinearSystems = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}

/* Some empty lines, since emptyCount is not implemented in susan! */
void setupDataStruc2(DATA *data)
{
  const struct FUNCTION_INFO funcInfo[1] = {{-1,"",omc_dummyFileInfo}};
  memcpy(data->modelData.functionNames, &funcInfo, data->modelData.nFunctions*sizeof(FUNCTION_INFO));
  
  const VAR_INFO** equationInfo_cref1 = (const VAR_INFO**)calloc(1,sizeof(VAR_INFO*));
  equationInfo_cref1[0] = &$Pz__varInfo;
  const VAR_INFO** equationInfo_cref2 = (const VAR_INFO**)calloc(1,sizeof(VAR_INFO*));
  equationInfo_cref2[0] = &$P$DER$Px__varInfo;
  const struct EQUATION_INFO equationInfo[2] = {
    {1,"SES_SIMPLE_ASSIGN 1",1,equationInfo_cref1},
    {2,"SES_SIMPLE_ASSIGN 2",1,equationInfo_cref2}
  };
  memcpy(data->modelData.equationInfo, &equationInfo, data->modelData.nEquations*sizeof(EQUATION_INFO));
  
  data->modelData.nProfileBlocks = 0 ;
  data->modelData.equationInfo_reverse_prof_index = (int*) malloc(data->modelData.nProfileBlocks*sizeof(int));
  
}

/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_sampleInit(DATA *data)
{

}

int function_updateSample(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  INFO(LOG_INIT, "updating start-values");
  INDENT(LOG_INIT);
  RELEASE(LOG_INIT);
  
  return 0;
}

const char *initialResidualDescription[1] = {"empty"};

int initial_residual(DATA *data, double *initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  INFO(LOG_RES_INIT, "updating initial residuals");
  INDENT(LOG_RES_INIT);
  RELEASE(LOG_RES_INIT);
  restore_memory_state(mem_state);
  
  return 0;
}

const int useSymbolicInitialization = 0; /* false */
int functionInitialEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  ERROR0(LOG_INIT, "The symbolic initialization was not generated.");
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundParameters(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


void eqFunction_1(DATA *data)
{
  modelica_real tmp0;
  tmp0 = sin((3.141592653589793 * ($Pk * time)));
  $Pz = tmp0;
}


void eqFunction_2(DATA *data)
{
  modelica_boolean tmp1;
  RELATIONHYSTERESIS(tmp1, $Pz, 0.1, 0, Greater);
  $P$DER$Px = (tmp1?-1.0:1.0);
}

int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_1(data);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data,int omc_thread_number)
{
  eqFunction_1(data);
  eqFunction_2(data);
}
static void (*functionODE_systems[1])(DATA *, int) = {
  functionODE_system0
};

void function_initMemoryState()
{
  push_memory_states(1);
}

int functionODE(DATA *data)
{
  int id,th_id;
  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();

  data->simulationInfo.discreteCall = 0;
  for (id=0; id<1; id++) {
    th_id = omp_get_thread_num();
    functionODE_systems[id](data,th_id);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  state mem_state;
 data->simulationInfo.discreteCall = 0;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

const char *zeroCrossingDescription[] =
{
  "z > 0.1", 
};

int function_ZeroCrossings(DATA *data, double *gout, double *t)
{
  state mem_state;
  modelica_boolean tmp1;
  
  mem_state = get_memory_state();
  tmp1 = GreaterZC($Pz,0.1, data->simulationInfo.backupRelations[0]);
  ZEROCROSSING(0, (tmp1)?1:-1);
  restore_memory_state(mem_state);
  
  return 0;
}

const char *relationDescription[] =
{
  "z > 0.1", 
};

int function_updateRelations(DATA *data, int evalforZeroCross)
{
  state mem_state;
  modelica_boolean tmp2;
  
  mem_state = get_memory_state();
  if (evalforZeroCross){
    tmp2 = GreaterZC($Pz,0.1, data->simulationInfo.backupRelations[0]);
    data->simulationInfo.backupRelations[0] = tmp2;
  } else {
    data->simulationInfo.backupRelations[0] = ($Pz > 0.1);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

const int INDEX_JAC_G = 0;
const int INDEX_JAC_A = 1;
const int INDEX_JAC_B = 2;
const int INDEX_JAC_C = 3;
const int INDEX_JAC_D = 4;

int initialAnalyticJacobianG(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianA(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianB(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianC(DATA* data)
{
  return 1;
}
int initialAnalyticJacobianD(DATA* data)
{
  return 1;
}

int functionJacG_column(DATA* data)
{
  return 0;
}
int functionJacA_column(DATA* data)
{
  state mem_state;
  int index = INDEX_JAC_A;
  mem_state = get_memory_state();
  
  int i;
  if(DEBUG_STREAM(LOG_DEBUG))
  {
    for(i=0; i<1; i++)
      INFO2(LOG_DEBUG, "col: col[%d] = %f", i, data->simulationInfo.analyticJacobians[index].resultVars[i]);
  }
  
  restore_memory_state(mem_state);
  return 0;
}
int functionJacB_column(DATA* data)
{
  return 0;
}
int functionJacC_column(DATA* data)
{
  return 0;
}
int functionJacD_column(DATA* data)
{
  return 0;
}

const char *linear_model_frame =
  "model linear_Events\n  parameter Integer n = 1; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n"
  "  parameter Real x0[1] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[1,1] = [%s];\n"
  "  parameter Real B[1,0] = zeros(1,0);%s\n"
  "  parameter Real C[0,1] = zeros(0,1);%s\n"
  "  parameter Real D[0,0] = zeros(0,0);%s\n"
  "  Real x[1](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[0];\n"
  "\n  Real x_Px = x[1];\n      \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_Events;\n"
;

#ifdef __cplusplus
}
#endif

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}

